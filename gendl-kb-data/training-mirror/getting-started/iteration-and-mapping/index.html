<!DOCTYPE HTML><html lang="en"><head><title>Iteration and Mapping</title><meta charset="UTF-8" /><link rel="icon" type="image/png" href="/gorn.png" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="/css/training-style.css" /><script src="/static/3rdpty/x3dom/x3dom.js" id="x3dom_script"></script><script id="svg-panzoom" src="/static/3rdpty/svgpanzoom/svg-pan-zoom.min.js"></script><script>
var gdliid = '/shared';</script><script src="/static/gwl/js/gdlajax1595.js"></script></head><body><div class="container mx-auto"><div class="main-page-item"><div class="mt-1 ml-2 mr-5"><h2>Iteration and Mapping</h2><p><a class="text-red-500" href="/getting-started/more-on-lists/index.html">&lt;-Previous</a><span class="font-bold"> | </span><a class="text-blue-500" href="/getting-started/index.html">^UP^</a><span class="font-bold"> | </span><a class="text-green-500" href="/getting-started/truss-example/index.html">Next-&gt;</a></p><p>Common Lisp provides a number of iteration and mapping macros and functions which enable us to process the
contents of lists, the most commonly used being<ul><li>Iteration - the macros <span class="macro">dolist</span> and <span class="macro">dotimes</span></li><li>Mapping - the functions <span class="function">mapcar</span>, <span class="function">mapcan</span> and <span class="function">mapc</span></li></ul>Common Lisp also defines 2 powerful and more general iteration macros, <span class="macro">do/do*</span> and <span class="macro">loop</span>, but they are outside the scope of this tutorial</p><h3>Iteration Macros</h3><ul><div class="grid-container-2"><div class="main-page-item"><li><span class="macro">dolist</span> - takes a list of a <em>variable</em> and an <em>expression</em> which returns a <em>list</em>, followed by a <em>body of expressions</em>. Optionally <span class="macro">dolist</span> can take a third element for its list, which is an expression which
will be evaluated and its value returned from the <span class="macro">dolist</span> expression once the <span class="macro">dolist</span> iteration has completed. The <em>body of expressions</em> is evaluated with the <em>variable</em> bound to successive elements in the list.<br />The example on the right first sets a return variable  <em>res</em> to <span class="value">nil</span>. It then iterates through the list <em>a</em>, multiplying each value by <span class="value">5</span> and pushing the result onto <em>res</em>. Finally <em>res</em> is returned from the <span class="macro">dolist</span> and set to <em>b</em>.<br />If you wanted to return the resultant list values in the same order as they
occur in the input list, you would need to wrap the dolist return value <em>res</em> in a call to the function <span class="function">reverse</span>. But because <em>res</em> is locally bound and will never be used after <em>b</em> has been evaluated, you could use the destructive function <span class="function">nreverse</span>, which is slightly more efficient than <span class="function">reverse</span></li></div><div class="main-page-item"><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(setq a (list 1 2 3 4 5 6))</span></p><span class="output">1 2 3 4 5 6)</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(setq b (let ((res nil))</span><span class="command-no-prefix" style="margin-left: 182px;">(dolist (var a res)</span><span class="command-no-prefix" style="margin-left: 203px;">(push (* var 5) res))))</span><span class="output">(30 25 20 15 10 5)</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(setq b (let ((res nil))</span><span class="command-no-prefix" style="margin-left: 182px;">(dolist (var a (nreverse res))</span><span class="command-no-prefix" style="margin-left: 203px;">(push (* var 5) res))))</span><span class="output">(5 10 15 20 25 30)</span></pre></div></div><div class="main-page-item"><p>It is also possible to use <span class="macro">dolist</span> without any return value argument, in which case you'd be relying on <em><b>side-effecting</b> within the body. The two examples shown are different ways of returning the length of a list</em></p></div><div class="main-page-item"><div class="repl-example"><pre><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(setq c (let ((len 0))</span><span class="command-no-prefix" style="margin-left: 189px;">(dolist (var a)</span><span class="command-no-prefix" style="margin-left: 210px;">(setf len (+ len 1)))</span><span class="command-no-prefix" style="margin-left: 196px;">len))</span><span class="output">6</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(setq c (let ((len 0))</span><span class="command-no-prefix" style="margin-left: 189px;">(dolist (var a)</span><span class="command-no-prefix" style="margin-left: 210px;">(incf len)</span><span class="command-no-prefix" style="margin-left: 189px;">len))</span><span class="output">6</span></pre></div></div><div class="main-page-item"><li><span class="macro">dotimes</span> - takes two required inputs, a <em>variable</em> and an <em>integer</em>, followed by a <em>body of expressions</em>. As with <span class="macro">dolist</span>, the list at the start of <span class="macro">dotimes</span>'s argument list can optionally <span class="macro">dotimes</span> have a third element, an expression which will  be evaluated and the resulting value returned once the <span class="macro">dotimes</span> has completed. The <em>body of expressions</em> are evaluated with the <em>variable</em> bound to successive integers between 0 and <em>integer</em> minus 1<p>In contrast to <span class="macro">dolist</span> which is generally used to iterate through a single list, using <span class="macro">dotimes</span> with the function <span class="function">nth</span> permits iteration on multiple lists</p><p>The first example shows <span class="macro">dotimes</span> being used to splice together 2 lists. The second example is the first <span class="macro">dolist</span> example converted to a <span class="macro">dotimes</span> implementation</p></li></div><div class="main-page-item"><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(setq a (list 1 2 3 4 5))</span></p><span class="output">(1 2 3 4 5)</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(setq b (list "a" "b" "c" "d" "e"))</span></p><span class="output">("a" "b" "c" "d" "e")</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(let ((res nil))</span><span class="command-no-prefix" style="margin-left: 112px;">(dotimes (n (length a) (nreverse res))</span><span class="command-no-prefix" style="margin-left: 126px;">(push (nth n a) res)</span><span class="command-no-prefix" style="margin-left: 126px;">(push (nth n b) res)))</span><span class="output">(1 "a" 2 "b" 3 "c" 4 "d" 5 "e")</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(setq b (let ((res nil))</span><span class="command-no-prefix" style="margin-left: 168px;">(dotimes (n (length a) (nreverse res))</span><span class="command-no-prefix" style="margin-left: 182px;">(push (* (nth n a) 5) res))))))</span><span class="output">(5 10 15 20 25)</span></pre></div></div></div></ul><h3>Mapping Functions</h3><ul><div class="grid-container-2"><div class="main-page-item"><li><span class="function">mapcar</span> - one of the most heavily used mapping functions, it takes a <em>function</em> and one or more <em>lists</em> and calls the <em>function</em> on successive elements of the <em>lists</em></li></div><div class="main-page-item"><div class="repl-example"><pre><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(defun plus2(i)</span><span class="command-no-prefix" style="margin-left: 119px;">(+ i 2))</span><span class="output">PLUS2</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(mapcar #'plus2 (list 1 2 3))</span></p><span class="output">(3 4 5)</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(defun list-product (a b)</span><span class="command-no-prefix" style="margin-left: 119px;">(* a b))</span><span class="output">LIST-PRODUCT</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(mapcar #'list-product (list 1 2 3) (list 4 5 6))</span></p><span class="output">(4 10 18)</span></pre></div></div><div class="main-page-item"><p><span class="function">mapcar</span> is very commonly used with a <em><b>lambda</b></em> or anonymous function. This effectively allows functions to be defined on the fly and they can be used
to map across multiple lists. The first example is an alternative to the <span class="macro">dotimes</span> example for splicing 2 lists together. Successive elements from the 2 input lists are bound to the <em><b>lambda</b></em> vailables <em>x</em> and <em>y</em> and the return value from the <em><b>lambda</b></em> expression appended to the return list. The second example replaces the <span class="function">LIST-PRODUCT</span> function with a <em><b>lambda</b> function to achieve the same result</em><p><span class="function">mapcar</span> can often be used to accomplish the same thing as <span class="macro">dolist</span> and may be less verbose. However, when the list processing becomes more complex <span class="macro">dolist</span> may have some advantage in clarity and debugging</p></p></div><div class="main-page-item"><div class="repl-example"><pre><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(flatten</span><span class="command-no-prefix" style="margin-left: 112px;">(mapcar</span><span class="command-no-prefix" style="margin-left: 126px;">#'(lambda(x y) (list x y))</span><span class="command-no-prefix" style="margin-left: 147px;">(list 1 2 3 4 5)</span><span class="command-no-prefix" style="margin-left: 147px;">(list "a" "b" "c" "d" "e")))</span><span class="output">(1 "a" 2 "b" 3 "c" 4 "d" 5 "e")</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">mapcar #'(lambda(x y) (* x y) (list 1 2 3) (list 4 5 6))</span></p><span class="output">(4 10 18)</span></pre></div></div><div class="main-page-item"><li><span class="function">mapcan</span> - takes a <em>function</em> and one or more <em>lists</em> like <span class="function">mapcar</span> but splices together the values returned by the <em>function</em></li></div><div class="main-page-item"><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(mapcan #'list (list 1 2 3 4 5) (list "a" "b" "c" "d" "e"))</span></p><span class="output">(1 "a" 2 "b" 3 "c" 4 "d" 5 "e")</span></pre></div></div><div class="main-page-item"><li><span class="function">mapc</span> is like <span class="function">mapcar</span> but it doesn't accumulate any data to return so the only reason to use it is for side-effecting. <span class="function">mapc</span> always returns is second argument (the first list provided). When only side-effecting is required <span class="function">mapc</span> may be a better option than <span class="macro">dolist</span> because is can traverse multiple lists in parallel</li></div><div class="main-page-item"><div class="repl-example"><pre><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(let ((x 0))</span><span class="command-no-prefix" style="margin-left: 133px;">(mapc #'(lambda(a) (setf x (+ x a))) (list 1 2 3))</span><span class="command-no-prefix" style="margin-left: 112px;">x)</span><span class="output">6</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(let ((x 0))</span><span class="command-no-prefix" style="margin-left: 126px;">(mapc #'(lambda(a b c) (setf x (+ x a b c)))</span><span class="command-no-prefix" style="margin-left: 154px;">(list 1 2 3) </span><span class="command-no-prefix" style="margin-left: 154px;">(list 4 5 6)</span><span class="command-no-prefix" style="margin-left: 154px;">(list 7 8 9))</span><span class="command-no-prefix" style="margin-left: 112px;">x)</span><span class="output">45</span></pre></div></div></div></ul></div></div></div></body></html>