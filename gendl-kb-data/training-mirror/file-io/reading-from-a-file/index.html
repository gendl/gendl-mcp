<!DOCTYPE HTML><html lang="en"><head><title>Reading from a file</title><meta charset="UTF-8" /><link rel="icon" type="image/png" href="/gorn.png" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="/css/training-style.css" /><script src="/static/3rdpty/x3dom/x3dom.js" id="x3dom_script"></script><script id="svg-panzoom" src="/static/3rdpty/svgpanzoom/svg-pan-zoom.min.js"></script><script>
var gdliid = '/shared';</script><script src="/static/gwl/js/gdlajax1595.js"></script></head><body><div class="container mx-auto"><div class="main-page-item"><div class="mt-1 ml-2 mr-5"><h2>Reading from a file</h2><p><a class="text-red-500" href="/file-io/writing-to-a-file/index.html">&lt;-Previous</a><span class="font-bold"> | </span><a class="text-blue-500" href="/file-io/index.html">^UP^</a><span class="font-bold"> | </span><a class="text-green-500" href="/file-io/example-1/index.html">Next-&gt;</a></p><div class="main-page-container" style="grid-template-columns: 700px auto;"><div class="main-page-item"><p>Compared with writing to a file, reading from a file is a much more involved process. As with writing a file, a stream is opened and connected to the file. But then the file contents need to be read, line by line, until the end of the file. In general we will not know how many lines are to be read. Once the data has been read, it needs to be converted or conditioned into a format that the application can use. This implies <ul><li>We know something about the format of the data being supplied</li><li>The data is supplied in that known format</li></ul>It is often the achilles heel of many applications which take data from the outside world and effort in making this interface as robust as possible is always time well spent</p><p>A general purpose function to read data from a text file may look something like this</p><div class="code-example"><pre><span class="code" style="margin-left: 0px;">(defun read-file (file))</span><span class="code" style="margin-left: 21px;">(let ((result))</span><span class="code" style="margin-left: 42px;">(with-open-file (str file :direction :input)</span><span class="code" style="margin-left: 84px;">(do ((line (read-line str nil 'eof)</span><span class="code" style="margin-left: 77px;">(read-line str nil 'eof)))</span><span class="code" style="margin-left: 77px;">((eql line 'eof) result)</span><span class="code" style="margin-left: 7px;">(setq result (append result (list line)))))))</span></pre></div><p>We have introduced the use of the CL macro <span class="macro">do</span> as part of the body of expressions wrapped in <span class="macro">with-open-file</span></p><p><span class="macro">do</span> accepts a list of variable expressions in the form <em>(variable initial-iteration subsequent-iterations</em>). The <em>initial-iteration</em> is an expression which is evaluated on the first iteration and <em>subsequent-iterations</em> is an expression evaluated on all subsequent iterations. In our case we are using the CL function <span class="function">read-line</span> The first argument is the stream which comes from <span class="macro">with-open-file</span>, the second argument determines if an end of file error should be signalled, in this case nil, and the third argument is the value returned when end of file is encountered. The output of read-line is set to the variable line which is appended into the result variable. The second list in <span class="macro">do</span> defines the condition to be met to end iteration (in this case, the value of line is the end of file value) and the value to be returned when this condition is T, in this case <span class="slot">result</span></p><p>Evaluating this function against the file created in the previous topic gives the following</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(read-file "c:/temp/report.txt")</span></p><span class="output">("Box Width 3" "Box Length 6" "Box Height 4" "Box Center 0.0,0.0,0.0" "Box Volume 72")</span></pre></div><p>The next task when reading a data file is generally parsing it to convert it into a format that our application can use. The following function, making use of our read-file function will do that and return an appropriate plist</p><div class="code-example"><pre><span class="code" style="margin-left: 0px;">(defun import-data (file)</span><span class="code" style="margin-left: 0px;">(let*</span><span class="code" style="margin-left: 14px;">((raw-data (read-file file))</span><span class="code" style="margin-left: 21px;">(res (mapcar #'(lambda(a) (glisp:split-regexp "\\s+" a)) raw-data))</span><span class="code" style="margin-left: 21px;">(res-1 (mapcan #'(lambda(a) (list (make-keyword (second a)) (third a))) res))</span><span class="code" style="margin-left: 21px;">(keywords (remove nil res-1 :key #'(lambda(a) (keywordp a))))</span><span class="code" style="margin-left: 21px;">(r nil))</span><span class="code" style="margin-left: 7px;">(dolist (k keywords r)</span><span class="code" style="margin-left: 28px;">(cond ((or (eq k :width) (eq k :length) (eq k :height))</span><span class="code" style="margin-left: 77px;">(setq r (append r (list k (read-safe-string (getf res-1 k))))))</span><span class="code" style="margin-left: 70px;">((eq k :center)</span><span class="code" style="margin-left: 77px;">(let ((co-ord (glisp:split-regexp "," (getf res-1 k))))</span><span class="code" style="margin-left: 56px;">(setq r (append</span><span class="code" style="margin-left: 161px;">r</span><span class="code" style="margin-left: 161px;">(list k (make-point (read-safe-string (first co-ord))</span><span class="code" style="margin-left: 301px;">(read-safe-string (second co-ord))</span><span class="code" style="margin-left: 301px;">(read-safe-string (third co-ord))))))))))))</span></pre></div><p>Working through the function<ul><li>We first read the data into a variable <em><b>raw-data</b></em>. This is a list of strings, where each string is a separate line from the file</li><li>The we use the function <span class="function">glisp:split-regexp</span> to split each string into separate words, breaking where there is one or more whitespaces (the regular-expression "\\s+")</li><li>Because we know the structure of the data, we can comfortably discarded the first word from each line and convert the second word into a keyword. By using <span class="function">mapcan</span> the local variable <em><b>res-1</b> becomes a plist of keyword and value, although each value is still a string</em><li>We need to convert the values into the correct data types, but it's different depending on what value we are considering. <span class="general-keyword">length</span>, <span class="general-keyword">width</span> and <span class="general-keyword">height</span> will all be numbers, whilst <span class="general-keyword">center</span> will be a point (vector).</li><li>Finally, we use the keywords to determine how to process the data and return a plist. A key point to note here is that we are not using the CL function <span class="function">read-string</span> as it does have some security vulnerabilities; to prevent this we use the GendL function <span class="function">read-safe-string</span> to convert the numbers as strings into real numbers</li></li>Evaluating the function in the REPL we get</ul><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(import-data "c:/temp/report.txt")</span></p><span class="output">(:WIDTH 3 :LENGTH 6 :HEIGHT 4 :CENTER #(0.0 0.0 0.0))</span></pre></div><p>One final point to note in the example code; there is virtually no error handling. Given the data file is one we generated automatically and are therefore in full control of, this is probably acceptable, but in general the interface functions like shown above need to be extreemly robust</p></p></div><div class="main-page-item"><h2>Resources</h2><table><tr><td><a href="/t4-resources/read-input.lisp"><img src="/common-images/lisp-file.png" style="width: 40px; height: auto;" /></a></td><td><a href="/t4-resources/read-input.lisp">read-input.lisp</a></td></tr><tr><td><a href="/t4-resources/report.txt"><img src="/common-images/txt-file.png" style="width: 40px; height: auto;" /></a></td><td><a href="/t4-resources/report.txt">report.txt</a></td></tr></table></div></div></div></div></div></body></html>