<!DOCTYPE HTML><html lang="en"><head><title>Conditionals</title><meta charset="UTF-8" /><link rel="icon" type="image/png" href="/gorn.png" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="/css/training-style.css" /><script src="/static/3rdpty/x3dom/x3dom.js" id="x3dom_script"></script><script id="svg-panzoom" src="/static/3rdpty/svgpanzoom/svg-pan-zoom.min.js"></script><script>
var gdliid = '/shared';</script><script src="/static/gwl/js/gdlajax1595.js"></script></head><body><div class="container mx-auto"><div class="main-page-item"><div class="mt-1 ml-2 mr-5"><h2>Conditionals</h2><p><a class="text-red-500" href="/getting-started/equality/index.html">&lt;-Previous</a><span class="font-bold"> | </span><a class="text-blue-500" href="/getting-started/index.html">^UP^</a><span class="font-bold"> | </span><a class="text-green-500" href="/getting-started/wall-example/index.html">Next-&gt;</a></p><p>We use conditionals mainly to implement logic in our computer programs. Common Lisp provides the following conditionals<ul><li><span class="special-operator">if</span></li><li><span class="macro">when</span></li><li><span class="macro">unless</span></li><li><span class="macro">cond</span></li><li><span class="macro">case</span></li></ul></p><h3><span class="special-operator">if</span></h3><p><span class="special-operator">if</span> is a special operator.</p><p>The syntax is <span class="general-keyword">(if test then [else])</span>, where<ul><li><span class="general-keyword">test</span> is an expression that will evaluate to T or NIL</li><li><span class="general-keyword">then</span> is an expression that is evaluated and its value returned if <em>test</em> is T</li><li><span class="general-keyword">else</span> is an optional argument which is an expression to be evalued and its value returned if <span class="general-keyword">test</span> is <span class="value">NIL</span>.</li><li>if <span class="general-keyword">else</span> is not provided, but <span class="general-keyword">test</span> returns <span class="value">NIL</span>, then <span class="special-operator">if</span> also returns <span class="value">NIL</span></li></ul></p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(if (> 1 0) (+ 3 4))</span></p><span class="output">7</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(if (< 1 0) (+ 3 4))</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(if (< 1 0) (+ 3 4)(+ 5 6))</span></p><span class="output">7</span></pre></div><p><span class="special-operator">if</span> only allows single expressions for the <span class="general-keyword">then</span> and <span class="general-keyword">else</span> arguments; if multiple expressions needs to be evaluated then the must be wrapped in a <span class="special-operator">progn</span> (which returns the last evaluated value in its body) or <span class="macro">prog1</span> (which evaluates all expressions in its body in order and finally returns the value of the first). Not that it matters much to the routine user, but note that <span class="special-operator">progn</span> is a special operator, whilst <span class="macro">prog1</span> is a macro (which you might imaging utilizes the former in its implementation).</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(defparameter *evaluated* NIL)</span></p><span class="output">*EVALUATED*</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(if (> 1 0)</span><span class="command-no-prefix" style="margin-left: 91px;">(progn (+ 1 2)</span><span class="command-no-prefix" style="margin-left: 140px;">(setf *evaluated* (not *evaluated*))</span><span class="command-no-prefix" style="margin-left: 140px;">(+ 4 5))</span><span class="command-no-prefix" style="margin-left: 91px;">(+ 3 2))</span><span class="output">9</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">*evaluated*</span></p><span class="output">T</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(if (> 1 0)</span><span class="command-no-prefix" style="margin-left: 91px;">(prog1 (+ 1 2)</span><span class="command-no-prefix" style="margin-left: 140px;">(setf *evaluated*  (not *evaluated*))</span><span class="command-no-prefix" style="margin-left: 140px;">(+ 4 5))</span><span class="command-no-prefix" style="margin-left: 91px;">(+ 3 2))</span><span class="output">3</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">*evaluated*</span></p><span class="output">NIL</span></pre></div><h3><span class="macro">when</span></h3><p><span class="macro">when</span> is a macro.</p><p>The syntax is <span class="general-keyword">(when test body)</span>, where <ul><li><span class="general-keyword">test</span>is an expression that will evaluate to <span class="value">T</span> or <span class="value">NIL</span>.</li><li><span class="general-keyword">body</span> is one or more expressions, an implicit <span class="special-operator">progn</span> such that each expression will be evaluated in order, and finally the value of the last one returned.</li><li>if <span class="general-keyword">test</span> returns <span class="value">NIL</span>, then the <span class="macro">when</span> expression likewise returns <span class="value">NIL</span></li></ul></p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(defparameter *evaluated* NIL)</span></p><span class="output">*EVALUATED*</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(when (> 1 0)</span><span class="command-no-prefix" style="margin-left: 77px;">(+ 1 2)</span><span class="command-no-prefix" style="margin-left: 77px;">(setf *evaluated* (not *evaluated*))</span><span class="command-no-prefix" style="margin-left: 77px;">(+ 4 5))</span><span class="output">9</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">*evaluated*</span></p><span class="output">T</span><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(when (< 1 0)</span><span class="command-no-prefix" style="margin-left: 77px;">(+ 1 2)</span><span class="command-no-prefix" style="margin-left: 77px;">(setf *evaluated* (not *evaluated*))</span><span class="command-no-prefix" style="margin-left: 77px;">(+ 4 5))</span></pre></div><h3><span class="macro">unless</span></h3><p><span class="macro">unless</span> is a macro and acts as the opposite of <span class="macro">when</span>. It takes the same arguments, but <span class="general-keyword">body</span> is only evaluated when <span class="general-keyword">test</span> returns <span class="value">NIL</span>)</p><h3><span class="macro">cond</span></h3><pr><span class="macro">cond</span> is a macro which allows multiple conditions to be tested.
The code associated with each condition is wrapped in an implicit
progn allowing multiple expressions to be evaluated per
condition. Each <span class="general-keyword">test</span> and <span class="general-keyword">body</span> of expressions is specified as a list and the <span class="general-keyword">body</span> of expressions associated with the first <span class="general-keyword">test</span> to evaluate to <span class="value">T</span> is evaluated and the value of the last expression in that <span class="general-keyword">body</span> returned. Once a <span class="general-keyword">test</span> has evaluated to <span class="value">T</span>, no further <span class="general-keyword">tests</span> are evaluated.</pr><div class="repl-example"><pre><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(cond ((> 1 2) (+ 3 4))</span><span class="command-no-prefix" style="margin-left: 63px;">((string= "peter" "paul") (+ 5 6))</span><span class="command-no-prefix" style="margin-left: 63px;">((equalp (list 1 2) (list 1 2)) (setq a (+ 7 8))</span><span class="command-no-prefix" style="margin-left: 287px;">(oddp a))</span><span class="command-no-prefix" style="margin-left: 63px;">(T 0))</span><span class="output">T</span></pre></div><p>In the example above, the final <span class="general-keyword">test</span> is always T so this is effectively the default if none of the prior <span class="general-keyword">test</span> expressions return T</p><h3><span class="macro">case</span></h3><p><span class="macro">case</span> is a macro which takes an <em>object</em> as a first argument, followd by lists of <em>key</em>-<em>expression</em> pairs. The <em>key</em><em>expression</em> pairs are then tested in order, and where the <em>object</em> is <span class="function">eql</span> to the <em>key</em>, or a member of the <em>key</em>, then the corresponding <em>expression</em> is evaluated and returned. Optionally <span class="general-keyword">T</span> or <span class="general-keyword">otherwise</span> may be specified as a catchall <em>key</em> at the end of the <span class="macro">case</span> expression, meaning that its corresponsing <em>expression</em> will be evauated and returned if and only if <em>object</em> is not <span class="function">eql</span> to, or a member of, any of the <em>keys</em>. Without such a <span class="general-keyword">otherwise</span> or <span class="general-keyword">T</span>, <span class="value">NIL</span> would be returned in such a non-matching situation.</p><div class="repl-example"><pre><span class="prompt" style="display: inline;">GDL-USER>&nbsp;&nbsp;</span><span class="command" style="margin-left: 0px;">(defun month-days (month &key (leap-year nil))</span><span class="command-no-prefix" style="margin-left: 63px;">(case month</span><span class="command-no-prefix" style="margin-left: 70px;">((1 3 5 7 8 10 12) 31)</span><span class="command-no-prefix" style="margin-left: 70px;">((4 6 9 11) 30)</span><span class="command-no-prefix" style="margin-left: 70px;">(2 (if leap-year 29 28))</span><span class="command-no-prefix" style="margin-left: 70px;">(otherwise "month must be between 1 and 12"))) </span><span class="output">MONTH-DAYS</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(month-days 3)</span></p><span class="output">31</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(month-days 2 :leap-year t)</span></p><span class="output">29</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(month-days 13)</span></p><span class="output">month must be between 1 and 12</span></pre></div><p></p><p>We could extend <span class="object">assembly-8</span>, used in the Lists tutorial as follows to make it a bit more flexible, ensuring that the number of box centers defined will always match the number of boxes to be created</p><div class="code-example"><pre><span class="code" style="margin-left: 0px;">(define-object assembly-8 (base-object)</span><span class="code" style="margin-left: 0px;">:input-slots</span><span class="code" style="margin-left: 0px;">((box-lengths (list 2 5 8 12)))</span><span class="code" style="margin-left: 0px;">:computed-slots</span><span class="code" style="margin-left: 0px;">((number-of-boxes (if (> (length (the box-lengths)) 3)</span><span class="code" style="margin-left: 21px;">3</span><span class="code" style="margin-left: 21px;">(length (the box-lengths))))</span><span class="code" style="margin-left: 0px;"></span><span class="code" style="margin-left: 7px;">(box-centers (case (the number-of-boxes)</span><span class="code" style="margin-left: 28px;">(1 (list (make-point 0 0 0)))</span><span class="code" style="margin-left: 28px;">(2 (list (make-point 0 0 0)</span><span class="code" style="margin-left: 42px;">(make-point 6 0 0)))</span><span class="code" style="margin-left: 28px;">(3 (list (make-point 0 0 0)</span><span class="code" style="margin-left: 49px;">(make-point 6 0 0)</span><span class="code" style="margin-left: 49px;">(make-point 12 0 0)))))</span><span class="code" style="margin-left: 21px;"></span><span class="code" style="margin-left: 7px;">(box-volumes (list-elements (the my-box) (the-element volume)))</span><span class="code" style="margin-left: 7px;">(box-1-volume (nth 0 (the box-volumes))))</span><span class="code" style="margin-left: 0px;"></span><span class="code" style="margin-left: 0px;">:objects</span><span class="code" style="margin-left: 0px;">((my-box :type 'box</span><span class="code" style="margin-left: 28px;">:sequence (:size (the number-of-boxes))</span><span class="code" style="margin-left: 28px;">:length (nth (the-child index) (the box-lengths))</span><span class="code" style="margin-left: 28px;">:width 2</span><span class="code" style="margin-left: 28px;">:height 1</span><span class="code" style="margin-left: 28px;">:center (nth (the-child index) (the box-centers)))))</span></pre></div><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(setq self (make-object 'assembly-8))</span></p><span class="output">#&#60;ASSEMBLY-8 #x2103F266ED></span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(the box-centers)</span></p><span class="output">(#(0.0 0.0 0.0) #(6.0 0.0 0.0) #(12.0 0.0 0.0))</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(setq self (make-object 'assembly-8 :box-lengths (list 3 8)))</span></p><span class="output">#&#60;ASSEMBLY-8 #x2103F25B2D></span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(the box-centers)</span></p><span class="output">(#(0.0 0.0 0.0) #(6.0 0.0 0.0))</span></pre></div><h2>Resources</h2><table><tr><td><a href="/t2-resources/using-conditionals.lisp"><img src="/common-images/lisp-file.png" style="width: 40px; height: auto;" /></a></td><td><a href="/t2-resources/using-conditionals.lisp">using-conditionals.lisp</a></td></tr></table></div></div></div></body></html>