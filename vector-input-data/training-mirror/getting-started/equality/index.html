<!DOCTYPE HTML><html lang="en"><head><title>Equality</title><meta charset="UTF-8" /><link rel="icon" type="image/png" href="/gorn.png" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="/css/training-style.css" /><script src="/static/3rdpty/x3dom/x3dom.js" id="x3dom_script"></script><script id="svg-panzoom" src="/static/3rdpty/svgpanzoom/svg-pan-zoom.min.js"></script><script>
var gdliid = '/shared';</script><script src="/static/gwl/js/gdlajax1595.js"></script></head><body><div class="container mx-auto"><div class="main-page-item"><div class="mt-1 ml-2 mr-5"><h2>Equality</h2><p><a class="text-red-500" href="/getting-started/functions-and-functions/index.html">&lt;-Previous</a><span class="font-bold"> | </span><a class="text-blue-500" href="/getting-started/index.html">^UP^</a><span class="font-bold"> | </span><a class="text-green-500" href="/getting-started/conditionals/index.html">Next-&gt;</a></p><p>Lisp defines 4 generic equality predicates. In order of "strictness" they are:<ul><li><span class="macro">eq</span></li><li><span class="macro">eql</span></li><li><span class="macro">equal</span></li><li><span class="macro">equalp</span></li></ul>When we say <span class="macro">eq</span> is the strictest test, we mean that it is most likely to return <span class="value">NIL</span>.  So any two items which compare as <span class="value">T</span> with <span class="macro">eq</span> will certainly compare as <span class="value">T</span> with <span class="macro">eql</span> and with all the other equality predicates below <span class="macro">eql</span> in the stack. A similar relationship may be drawn between <span class="macro">eql</span> and <span class="macro">equal</span>, and likewise between <span class="macro">equal</span> and <span class="macro">equalp</span>. Now we will show some examples and describe
the characteristics of each of these equality predicates.</p><h3><span class="macro">eq</span></h3><p><em><b>eq</b></em> takes 2 objects as arguments and returns t if they are identical<br />Integers and Characters have the same symbol-name and value, so when comparing Integers and Characters, whilst it may appear <span class="macro">eq</span> is testing for value equality, it is in fact testing for object equality.<br /><span class="macro">eq</span> is fast but is only safe to use when the types (i.e. classes) of the objects being tested are known in advance</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">((eq 1 1)</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eq #\a #\a)</span></p><span class="output">T</span></pre></div><p>Floats, lists, and strings however are just pointers to the actual objects containing the value in memory, so <span class="macro">eq</span> will generally return NIL if either of the objects being tested is a float, list or string. This is because
two floats, lists, or strings, even though they may appear to be identical, typically are existing in two different places in memory.</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eq 1.0 1.0)</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eq "a" "a")</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eq (list 1 2 3) (list 1 2 3))</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eq 1 1.0)</span></p><span class="output">NIL</span></pre></div><h3><span class="macro">eql</span></h3><p><em><b>eql</b></em> behaves as <em><b>eq</b></em> except it guarantees to consider 2 objects of the same class representing the same <em>numeric or character</em> value to be equal</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eql 1.0 1.0)</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eql "a" "a")</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eql (list 1 2 3) (list 1 2 3))</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(eql 1 1.0)</span></p><span class="output">NIL</span></pre></div><h3><span class="macro">equal</span></h3><p><span class="macro">equal</span> behaves as <span class="macro">eql</span> except different objects may be considered equivalent if their values look the same.
This is particularly useful when testing for equality between two strings or two lists</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equal "a" "a")</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equal (list 1 2 3) (list 1 2 3))</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equal 1 1.0)</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equal "A" "a")</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equal (list 1 2 3) (list 1 2 3.0))</span></p><span class="output">NIL</span></pre></div><h3><span class="macro">equalp</span></h3><p><span class="macro">equalp</span> behaves as <span class="macro">equal</span>, except numbers are considered equal if they are mathematically equal,
 and string equality is not case-sensitive</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equalp 1 1.0)</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equalp "A" "a")</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(equalp (list 1 2 3) (list 1 2 3.0))</span></p><span class="output">T</span></pre></div><p>In addition to the above, Lisp defines specific equality tests (predicates) for numbers and strings</p><h3>Number Comparison</h3><ul><li><span class="macro">&lt;</span> - less than</li><li><span class="macro">&lt;=</span> - less than or equal</li><li><span class="macro">=</span> - equal</li><li><span class="macro">&gt;=</span> - greater than or equal</li><li><span class="macro">&gt;</span> - greater than</li><li><span class="macro">/=</span> - not equal</li></ul><p>All of these functions take one or more arguments, and with the exception of <span class="macro">/=</span>, all make their comparisons between consecutive pairs. With <span class="macro">/=</span>, it compares all posible combinations of the arguments</p><div class="repl-example"><pre><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(> 5 4 3)</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(> 5 4 5)</span></p><span class="output">NIL</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(/= 1 2 3 4)</span></p><span class="output">T</span><p style="display: inline;"><span class="prompt" style="display: inline;">GDL-USER>&nbsp;</span><span class="command" style="display: inline;">(/= 1 1 4 1)</span></p><span class="output">NIL</span></pre></div><p>Specific tests for number values are also avaliable<ul><li><span class="function">zerop</span> - the number is zero</li><li><span class="function">plusp</span> - the number is greater than zero</li><li><span class="function">minusp</span> - the number is less than zero</li></ul></p><p>When comparing Float numbers, it is better to use the GendL functions <span class="function">near-to?</span> and <span class="function">near-zero?</span>. These return <span class="value">T</span> if the two arguments are within <span class="variable-name">*ZERO-EPSILON*</span> of each other</p><h3>String Comparison</h3><p>string comparison is similar number comparison, except there is one variant (the first shown below)
which is case-sensitive and one (the second) which is case-insentitive. These functions accept two string arguments.</p><ul><li><span class="macro">string<</span>, <span class="macro">string-lessp</span> - one string less than another</li><li><span class="macro">string=</span>, <span class="macro">string-equal</span> - one string equal to another</li><li><span class="macro">string></span>, <span class="macro">string-greaterp</span> - one string greater than another</li><li><span class="macro">string/=</span>, <span class="macro">string-not-equal</span> - strings are not equal</li></ul><p> These functions  also have keyword inputs <span class="general-keyword">(:start1 :end1 :start2 and :end2)</span> to enable substrings of the supplied strings to be compared</p><h3>Object Type</h3><p>Finally, Lisp defines predicates to test for object type<ul><li><span class="macro">numberp</span> - returns <span class="value">T</span> if the object is a number.</li><li><span class="macro">floatp</span> - returns <span class="value">T</span> if the object is a float.</li><li><span class="macro">stringp</span> - returns <span class="value">T</span> if the object is a string.</li><li><span class="macro">characterp</span> - returns <span class="value">T</span> if the object is a character.</li><li><span class="macro">listp</span> - returns <span class="value">T</span> if the object is a list.</li></ul></p><h2>Resources</h2><table><tr><td><a href="/t2-resources/equality.lisp"><img src="/common-images/lisp-file.png" style="width: 40px; height: auto;" /></a></td><td><a href="/t2-resources/equality.lisp">equality.lisp</a></td></tr></table></div></div></div></body></html>